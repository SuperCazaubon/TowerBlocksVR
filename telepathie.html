<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Three.js Cardboard Debug</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  .error-box {
    position: fixed;
    top:0;
    left:0;
    width:100%;
    background:red;
    color:white;
    padding:10px;
    z-index:9999;
    font-family: monospace;
    white-space: pre-wrap;
  }
</style>
</head>
<body>
<div id="hud" style="
  position:fixed;
  top:200px; left:200px;
  color:white;
  font-size:8px;
  background:rgba(0,0,0,0.5);
  padding:5px;
  border-radius:5px;
  ">
Acceleration=(0,0,0)
velocity=(0,0,0)
rotationRate=(0,0,0)
CameraRot=(0,0,0) 
position=(0,0,0)
CameraPos=(0,0,0)
GPS=(0,0,0,0)
</div>

<script type="module">
var global_latitude=null, global_longitude=null, global_altitude=null, global_accuracy=null;
var global_acceleration = {x:0, y:0, z:0};
var global_rotationRate = {alpha:0, beta:0, gamma:0};
var global_position = {x:0, y:0, z:0};
var global_velocity = {x:0, y:0, z:0};
var global_lastTimestamp = null;

// --- Code Three.js ---
import * as THREE from "./cdn.jsdelivr.net/npm/three@0.151.3/build/three.module.js";
import { StereoEffect } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/effects/StereoEffect.js";
import { DeviceOrientationControls } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/controls/DeviceOrientationControls.js";

 // --- Scène ---
const global_scene = new THREE.Scene();
global_scene.background = new THREE.Color(0x202020);

// --- Caméra ---
const global_camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
global_camera.position.set(0, 1.6, 2); // hauteur yeux
global_camera.lookAt(0,1.6,-2);

  
// --- Renderer ---
const global_renderer = new THREE.WebGLRenderer({antialias:true});
global_renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(global_renderer.domElement);

// --- StereoEffect ---
const global_effect = new StereoEffect(global_renderer);
global_effect.setSize(window.innerWidth, window.innerHeight);
global_effect.eyeSeparation = 0.064; // ajustable pour Cardboard

// --- Lumières ---
global_scene.add(new THREE.AmbientLight(0xffffff,0.6));
const global_dirLight = new THREE.DirectionalLight(0xffffff,0.8);
global_dirLight.position.set(5,10,5);
global_scene.add(global_dirLight);

// --- Sol étendu ---
const global_floor = new THREE.Mesh(
  new THREE.PlaneGeometry(50,50),
  new THREE.MeshPhongMaterial({color:0x333333})
);
global_floor.rotation.x = -Math.PI/2;
global_scene.add(global_floor);

// --- Cube central plus grand ---
const global_cube = new THREE.Mesh(
  new THREE.BoxGeometry(2,2,2),
  new THREE.MeshPhongMaterial({color:0xff5533})
);
global_cube.position.set(0,1.6,-3);
global_scene.add(global_cube);


// --- Repères visuels ---

// Fonction utilitaire pour créer un label
function createLabel(text, color=0xffffff) {
  const canvas = document.createElement('canvas');
  const size = 128;
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#' + color.toString(16).padStart(6,'0');
  ctx.font = 'bold 64px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, size/2, size/2);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);
  sprite.scale.set(0.5,0.5,0.5); // taille du label
  return sprite;
}

// Ajouter labels aux axes
const global_axesHelper = new THREE.AxesHelper(5);
global_scene.add(global_axesHelper);

const global_labelX = createLabel('X', 0xff0000); // red
global_labelX.position.set(5.5, 0, 0); // légèrement au bout de l'axe X
global_scene.add(global_labelX);

const global_labelY = createLabel('Y', 0x00ff00); //green
global_labelY.position.set(0, 5.5, 0); // légèrement au bout de l'axe Y
global_scene.add(global_labelY);

const global_labelZ = createLabel('Z', 0x0000ff); //blue
global_labelZ.position.set(0, 0, 5.5); // légèrement au bout de l'axe Z
global_scene.add(global_labelZ);


// -----  Ligne de regard -----
const global_materialLine = new THREE.LineBasicMaterial({ color: 0xffff00 });
const global_points = [
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(0, 0, -5) // longueur de la ligne
];
const global_geometryLine = new THREE.BufferGeometry().setFromPoints(global_points);
const global_gazeLine = new THREE.Line(global_geometryLine, global_materialLine);
global_camera.add(global_gazeLine);
global_scene.add(global_camera);
 

// --- Contrôles orientation ---
const global_controls = new DeviceOrientationControls(global_camera);
global_controls.enabled = true;

const global_raycaster = new THREE.Raycaster();
const global_pointer = new THREE.Vector2(0, 0); // centre de l'écran

function checkGaze() {
  global_raycaster.setFromCamera(global_pointer, global_camera);
  const intersects = global_raycaster.intersectObject(global_cube);
  if (intersects.length > 0) {
    global_cube.scale.set(2, 2, 2); // grossit si regardé
  } else {
    global_cube.scale.set(1, 1, 1);
  }
}

function errorOutput(msg){
	const div = document.createElement('div');
	div.className = 'error-box';
	div.innerText = msg;
	document.body.appendChild(div);
}

function getGPS(){
	if (navigator.geolocation) {
	  navigator.geolocation.getCurrentPosition(function(positionGPS) {
		global_latitude= positionGPS.coords.latitude;
		global_longitude= positionGPS.coords.longitude;
		if( positionGPS.coords.altitude) 
			global_altitude= positionGPS.coords.altitude;
		global_accuracy= positionGPS.coords.accuracy;
	  }, function(errorGPS) {
		errorOutput("Erreur GPS:"+ errorGPS.message);
	  }, {
		enableHighAccuracy: true,
		timeout: 15000,
		maximumAge: 0
	  });
	}
}




function resetPosition() {
  global_position = {x:0, y:0, z:0};
  global_velocity = {x:0, y:0, z:0};
}



function updateHUD() {
  const pos = global_camera.position;
  const rot = global_camera.rotation;
  const a = global_acceleration;
  const r = global_rotationRate;
  const v = global_velocity;
  const p = global_position;
  document.getElementById('hud').innerText = ``;
  document.getElementById('hud').innerText += `Acceleration=(${a.x?.toFixed(2)}, ${a.y?.toFixed(2)}, ${a.z?.toFixed(2)}) \n`;
  document.getElementById('hud').innerText += `velocity=(${v.x?.toFixed(1)}, ${v.y?.toFixed(1)}, ${v.z?.toFixed(1)}) \n`;
  document.getElementById('hud').innerText += `RotationRate=(${r.alpha?.toFixed(1)}, ${r.beta?.toFixed(1)}, ${r.gamma?.toFixed(1)}) \n`;
  document.getElementById('hud').innerText += `CameraRot=(${rot.x.toFixed(2)}, ${rot.y.toFixed(2)}, ${rot.z.toFixed(2)}) \n`;
  document.getElementById('hud').innerText += `position=(${p.x?.toFixed(1)}, ${p.y?.toFixed(1)}, ${p.z?.toFixed(1)}) \n`;
  document.getElementById('hud').innerText += `CameraPos=(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) \n`;
  document.getElementById('hud').innerText += `GPS=(${global_latitude?.toFixed(1)}, ${global_longitude?.toFixed(1)}, ${global_altitude?.toFixed(1)}, ${global_accuracy?.toFixed(1)} ) \n`;
}


// --- Animation ---
function animate(){
  requestAnimationFrame(animate);
  getGPS();
  global_cube.rotation.x += 0.01;
  global_cube.rotation.y += 0.01;
  global_controls.update();
  global_effect.render(global_scene,global_camera);
  checkGaze();
  updateHUD();
}
animate();



// Gestion globale des erreurs
window.addEventListener('error', e => {
 const msg = e.message + "\n" + e.filename + ":" + e.lineno;
 errorOutput(msg);
});

// --- UnHandledRejection ---
window.addEventListener('unhandledrejection', e => {
 const msg = 'Unhandled Promise Rejection:\n' + e.reason;
 errorOutput(msg);
});

// --- DeviceMotion ---
window.addEventListener('devicemotion', (e) => {
  const t = e.timeStamp;
  global_acceleration = event.acceleration;
  global_rotationRate = event.rotationRate;
  if(global_lastTimestamp) {
    const dt = (t - global_lastTimestamp)/1000; // s
    ['x','y','z'].forEach(axis=>{
      const a = e.acceleration[axis] || 0;
      global_velocity[axis] += a * dt;
      global_position[axis] += global_velocity[axis] * dt;
    });
  }
  global_lastTimestamp = t;
});

// --- Resize ---
window.addEventListener("resize", ()=>{
  global_camera.aspect = window.innerWidth/window.innerHeight;
  global_camera.updateProjectionMatrix();
  global_renderer.setSize(window.innerWidth, window.innerHeight);
  global_effect.setSize(window.innerWidth, window.innerHeight);
});

// --- TouchStart ---
window.addEventListener('touchstart', () => {
  global_raycaster.setFromCamera(global_pointer, global_camera);
  const intersects = global_raycaster.intersectObject(global_cube);
  if (intersects.length > 0) {
    global_cube.material.color.set(Math.random() * 0xffffff);
  }
});

</script>
</body>
</html>
