<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tower Blocks VR (IndexV7)</title>
  <meta name="viewport" content="width=device-width,user-scalable=no">
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #game { width:100%; height:100%; }
  </style>
</head>
<body>
<div id="game"></div>

<script type="module">
import * as THREE from "./cdn.jsdelivr.net/npm/three@0.151.3/build/three.module.js";
import { VRButton } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/webxr/VRButton.js";
import { FontLoader } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/geometries/TextGeometry.js";

// ---------------- Stage ----------------
class Stage {
    constructor() {
        this.container = document.getElementById("game");
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.xr.enabled = true;
        this.container.appendChild(this.renderer.domElement);
        this.container.appendChild(VRButton.createButton(this.renderer));

        this.scene = new THREE.Scene();

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        this.camera.position.set(6, 12, 30);
        this.camera.lookAt(0,6,0);
        this.scene.add(this.camera);

        let light = new THREE.DirectionalLight(0xffffff, 0.5);
        light.position.set(0, 499, 0);
        this.scene.add(light);
        this.scene.add(new THREE.AmbientLight(0xffffff,0.4));

        // Ground
        const groundTex = new THREE.TextureLoader().load('./cdn.jsdelivr.net/npm/three@0.151.3/examples/textures/terrain/grasslight-big.jpg');
        groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
        groundTex.repeat.set(10,10);
        const groundMat = new THREE.MeshToonMaterial({ map: groundTex });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMat);
        ground.rotation.x = -Math.PI/2;
        this.scene.add(ground);

        // Clouds
        const cloudTex = new THREE.TextureLoader().load('./cdn.jsdelivr.net/npm/three@0.151.3/examples/textures/sprites/cloud.png');
        this.clouds = [];
        for(let i=0;i<15;i++){
            const mat = new THREE.SpriteMaterial({ map: cloudTex, opacity:0.5, transparent:true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set((Math.random()-0.5)*100,10+Math.random()*10,(Math.random()-0.5)*100);
            sprite.scale.set(15,15,1);
            this.scene.add(sprite);
            this.clouds.push(sprite);
        }

        window.addEventListener("resize",()=>this.onResize());
    }

    render(callback){
        this.clouds.forEach(c=>{c.position.x+=0.01;if(c.position.x>50)c.position.x=-50;});
        if(callback) callback();
        this.renderer.render(this.scene,this.camera);
    }

    onResize(){
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

// ---------------- HUD ----------------
class HUD {
    constructor(scene) {
        this.scene = scene;
        this.font = null;
        this.scoreMesh = null;
        this.instructionsMesh = null;
        this.gameOverMesh = null;
        this.startMesh = null;

        const loader = new FontLoader();
        loader.load("./cdn.jsdelivr.net/npm/three@0.151.3/examples/fonts/helvetiker_regular.typeface.json", (font) => {
            this.font = font;
			this.screenPos={x:-2, y:6, z:0};
            this.scoreMesh = this.makeText("Score 0", 1, 0xffff00);
            this.scoreMesh.position.set(this.screenPos.x-1,this.screenPos.y+4,this.screenPos.z);
            scene.add(this.scoreMesh);

            this.instructionsMesh = this.makeText("Press SPACE or Click", 0.8, 0x00ffcc);
            this.instructionsMesh.position.set(this.screenPos.x-1,this.screenPos.y-2,this.screenPos.z);
            scene.add(this.instructionsMesh);

            this.gameOverMesh = this.makeText("GAME OVER", 1.5, 0xff3333);
            this.gameOverMesh.position.set(this.screenPos.x-1,this.screenPos.y,this.screenPos.z);
            this.gameOverMesh.visible = false;
            scene.add(this.gameOverMesh);

            this.startMesh = this.makeText("START", 1.2, 0x33ff33);
            this.startMesh.position.set(this.screenPos.x-1,this.screenPos.y-4,this.screenPos.z);
            scene.add(this.startMesh);
        });
    }

    makeText(text, size, color) {
        const geometry = new TextGeometry(text, { font:this.font, size, height:0.2 });
        const material = new THREE.MeshBasicMaterial({ color });
        return new THREE.Mesh(geometry, material);
    }

    updateText(mesh, newText, size=1, color=0xffffff) {
        if(!this.font || !mesh) return;
        mesh.geometry.dispose();
        mesh.geometry = new TextGeometry(newText, { font:this.font, size, height:0.2 });
        mesh.material.color.set(color);
    }

    setScore(score) { this.updateText(this.scoreMesh, `Score ${score}`,1,0xffff00); }
    showInstructions(show){ if(this.instructionsMesh) this.instructionsMesh.visible=show; }
    showGameOver(show){ if(this.gameOverMesh) this.gameOverMesh.visible=show; }
    setStartText(text){ this.updateText(this.startMesh, text,1.2,0x33ff33); }
}

// ---------------- Block ----------------
class Block {
    constructor(prevBlock) {
        this.STATES = { ACTIVE:"active", STOPPED:"stopped", MISSED:"missed" };
        this.MOVE_AMOUNT = 12;

        this.dimension = { width:0, height:0, depth:0 };
        this.position = { x:0, y:0, z:0 };
        this.targetBlock = prevBlock;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? "x" : "z";
        this.workingDimension = this.index % 2 ? "width" : "depth";

        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : -15;

        this.color = this.targetBlock ? new THREE.Color(Math.random(), Math.random(), Math.random()) : 0x333344;
        this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;
        this.speed = -0.1 - (this.index * 0.005);
        if (this.speed < -4) this.speed = -4;
        this.direction = this.speed;

        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.translate(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2);
        let material = new THREE.MeshToonMaterial({ color:this.color });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(this.position.x, this.position.y, this.position.z);

        if (this.state === this.STATES.ACTIVE) {
            this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
    }

    reverseDirection() { this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed); }

    place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = { plane:this.workingPlane, direction:this.direction };

        if (this.dimension[this.workingDimension] - overlap < 0.3) {
            overlap = this.dimension[this.workingDimension];
            blocksToReturn.bonus = true;
            this.position.x = this.targetBlock.position.x;
            this.position.z = this.targetBlock.position.z;
            this.dimension.width = this.targetBlock.dimension.width;
            this.dimension.depth = this.targetBlock.dimension.depth;
        }

        if (overlap > 0) {
            let choppedDimensions = { ...this.dimension };
            choppedDimensions[this.workingDimension] -= overlap;
            this.dimension[this.workingDimension] = overlap;

            let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
            placedGeometry.translate(this.dimension.width/2, this.dimension.height/2, this.dimension.depth/2);
            let placedMesh = new THREE.Mesh(placedGeometry, this.mesh.material);

            let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
            choppedGeometry.translate(choppedDimensions.width/2, choppedDimensions.height/2, choppedDimensions.depth/2);
            let choppedMesh = new THREE.Mesh(choppedGeometry, this.mesh.material);

            let choppedPosition = { ...this.position };
            if (this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
                this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
            } else {
                choppedPosition[this.workingPlane] += overlap;
            }

            placedMesh.position.set(this.position.x, this.position.y, this.position.z);
            choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);

            blocksToReturn.placed = placedMesh;
            if (!blocksToReturn.bonus) blocksToReturn.chopped = choppedMesh;
        } else {
            this.state = this.STATES.MISSED;
        }
        return blocksToReturn;
    }

    tick() {
        if (this.state === this.STATES.ACTIVE) {
            let value = this.position[this.workingPlane];
            if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT) this.reverseDirection();
            this.position[this.workingPlane] += this.direction;
            this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
    }
}

// ---------------- Game ----------------
class Game {
    constructor() {
        this.STATES = { LOADING:"loading", PLAYING:"playing", READY:"ready", ENDED:"ended", RESETTING:"resetting" };
        this.blocks = [];
        this.state = this.STATES.LOADING;
        this.stage = new Stage();
        this.hud = new HUD(this.stage.scene);

        this.newBlocks = new THREE.Group();
        this.placedBlocks = new THREE.Group();
        this.choppedBlocks = new THREE.Group();
        this.stage.scene.add(this.newBlocks, this.placedBlocks, this.choppedBlocks);

        this.addBlock();
        this.state = this.STATES.READY;

        document.addEventListener("keydown", (e)=>{ if(e.code==="Space") this.onAction(); });
        document.addEventListener("click", ()=>this.onAction());

        // controller VR
        const controller = this.stage.renderer.xr.getController(0);
        controller.addEventListener('selectstart',()=>this.onAction());
        this.stage.scene.add(controller);

        this.stage.renderer.setAnimationLoop(()=>this.tick());
    }

    onAction() {
        switch(this.state){
            case this.STATES.READY: this.startGame(); break;
            case this.STATES.PLAYING: this.placeBlock(); break;
            case this.STATES.ENDED: this.restartGame(); break;
        }
    }

    startGame() {
        this.score = 0;
        this.hud.setScore(this.score);
        this.hud.showInstructions(false);
        this.hud.showGameOver(false);
        this.hud.setStartText("");
        this.state = this.STATES.PLAYING;
        this.addBlock();
    }

    restartGame() {
        this.blocks = this.blocks.slice(0,1);
        this.placedBlocks.clear();
        this.choppedBlocks.clear();
        this.startGame();
    }

    placeBlock() {
        let currentBlock = this.blocks[this.blocks.length-1];
        let newBlocks = currentBlock.place();
        this.newBlocks.remove(currentBlock.mesh);
        if (newBlocks.placed) this.placedBlocks.add(newBlocks.placed);
        if (newBlocks.chopped){
            this.choppedBlocks.add(newBlocks.chopped);
            newBlocks.chopped.userData = { velocity: -0.2 };
        }
        this.addBlock();
    }

    addBlock() {
        let lastBlock = this.blocks[this.blocks.length-1];
        if(lastBlock && lastBlock.state===lastBlock.STATES.MISSED) return this.endGame();

        this.score = this.blocks.length-1;
        this.hud.setScore(this.score);

        let block = new Block(lastBlock);
        this.newBlocks.add(block.mesh);
        this.blocks.push(block);

        // déplacer la caméra si besoin
        this.stage.camera.position.y = 12 + block.index*2;
    }

    endGame() {
        this.state = this.STATES.ENDED;
        this.hud.showGameOver(true);
        this.hud.setStartText("RESTART");
        this.hud.showInstructions(true);
    }

    tick() {
        if(this.blocks.length>0) this.blocks[this.blocks.length-1].tick();
        this.choppedBlocks.children.forEach(mesh=>{
            if(mesh.userData.velocity){
                mesh.position.y += mesh.userData.velocity;
                mesh.userData.velocity -= 0.01;
                if(mesh.position.y<-50) this.choppedBlocks.remove(mesh);
            }
        });
        this.stage.render();
    }
}

new Game();
</script>
</body>
</html>
