<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tower Blocks VR + OrbitControls (IndexV8)</title>
  <meta name="viewport" content="width=device-width,user-scalable=no">
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
  </style>
</head>
<body>


<script type="module">
import * as THREE from "./cdn.jsdelivr.net/npm/three@0.151.3/build/three.module.js";
import { VRButton } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/webxr/VRButton.js";
import { OrbitControls } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/controls/OrbitControls.js";
import { FontLoader } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/loaders/FontLoader.js";
import { TextGeometry } from "./cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/geometries/TextGeometry.js";

// ---------------- Stage ----------------
class Stage {
    constructor() {
        this.container = document.body;
        this.renderer = new THREE.WebGLRenderer({ antialias:true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.xr.enabled = true;
        this.container.appendChild(this.renderer.domElement);
        this.container.appendChild(VRButton.createButton(this.renderer));

        this.scene = new THREE.Scene();

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight,0.1,2000);
        this.camera.position.set(6,1.6,30); // hauteur fixe pour VR
        this.camera.lookAt(0,1.6,0);
        this.scene.add(this.camera);

        // OrbitControls pour vue normale
        this.controls = new OrbitControls(this.camera,this.renderer.domElement);
        this.controls.target.set(0,6,0);
        this.controls.update();

        let light = new THREE.DirectionalLight(0xffffff,0.5);
        light.position.set(0,499,0);
        this.scene.add(light);
        this.scene.add(new THREE.AmbientLight(0xffffff,0.4));

        // Ground
        const groundTex = new THREE.TextureLoader().load('./cdn.jsdelivr.net/npm/three@0.151.3/examples/textures/terrain/grasslight-big.jpg');
        groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
        groundTex.repeat.set(10,10);
        const groundMat = new THREE.MeshToonMaterial({ map:groundTex });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), groundMat);
        ground.rotation.x = -Math.PI/2;
        this.scene.add(ground);

        // Clouds
        const cloudTex = new THREE.TextureLoader().load('./cdn.jsdelivr.net/npm/three@0.151.3/examples/textures/sprites/cloud.png');
        this.clouds = [];
        for(let i=0;i<15;i++){
            const mat = new THREE.SpriteMaterial({ map:cloudTex, opacity:0.5, transparent:true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set((Math.random()-0.5)*100,10+Math.random()*10,(Math.random()-0.5)*100);
            sprite.scale.set(15,15,1);
            this.scene.add(sprite);
            this.clouds.push(sprite);
        }

        window.addEventListener("resize",()=>this.onResize());
    }

    render(){
        this.clouds.forEach(c=>{ c.position.x+=0.01; if(c.position.x>50) c.position.x=-50; });


        // Désactiver OrbitControls si en VR
        if(this.renderer.xr.isPresenting) this.controls.enabled=false;
        else this.controls.enabled=true;

        this.controls.update();
        this.renderer.render(this.scene,this.camera);
    }

    onResize(){
        this.camera.aspect = window.innerWidth/window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth,window.innerHeight);
    }
}

// ---------------- HUD ----------------
class HUD {
    constructor(scene,camera){
        this.scene=scene;
        this.camera=camera; // référence caméra VR
        this.font=null;
        this.scoreMesh=null;
        this.instructionsMesh=null;
        this.gameOverMesh=null;
        this.startMesh=null;

        const loader = new FontLoader();
        loader.load("./cdn.jsdelivr.net/npm/three@0.151.3/examples/fonts/helvetiker_regular.typeface.json", font=>{
            this.font=font;

            this.scoreMesh=this.makeText("Score 0",1,0xffff00);
            this.instructionsMesh=this.makeText("Press SPACE or Click",0.8,0x00ffcc);
            this.gameOverMesh=this.makeText("GAME OVER",1.5,0xff3333);
            this.startMesh=this.makeText("START",1.2,0x33ff33);
			this.gameOverMesh.visible = false;
		
            // ajouter à la scène
            scene.add(this.scoreMesh,this.instructionsMesh,this.gameOverMesh,this.startMesh);

            // position initiale devant la caméra
            this.updatePosition(true);
        });
    }

    makeText(text,size,color){
        const geometry=new TextGeometry(text,{font:this.font,size,height:0.2});
        const material=new THREE.MeshBasicMaterial({color});
        return new THREE.Mesh(geometry,material);
    }

    updateText(mesh,newText,size=1,color=0xffffff){
        if(!this.font||!mesh) return;
        mesh.geometry.dispose();
        mesh.geometry=new TextGeometry(newText,{font:this.font,size,height:0.2});
        mesh.material.color.set(color);
    }

    setScore(score){ this.updateText(this.scoreMesh,`Score ${score}`,1,0xffff00); }
    showInstructions(show){ if(this.instructionsMesh) this.instructionsMesh.visible=show; }
    showGameOver(show){ if(this.gameOverMesh) this.gameOverMesh.visible=show; }
    setStartText(text){ this.updateText(this.startMesh,text,1.2,0x33ff33); }

    // mettre HUD devant les yeux
    updatePosition(force){
		//alert('updatePosition('+force+')');
		let posCamX=0,posCamY=0,posCamZ=0;
		if(!force){
			if(!this.camera) return;
			posCamX=this.camera.position.x;
			posCamY=this.camera.position.y;
			posCamZ=this.camera.position.z;
	    }	

	
        const offsetY=0.5; // au-dessus de la caméra
        const offsetZ=-2;  // 2 mètres devant
        this.scoreMesh.position.set(			posCamX,			posCamY+offsetY+6,	posCamZ+offsetZ	);
        this.instructionsMesh.position.set(		posCamX,			posCamY+5, 			posCamZ+offsetZ	);
        this.gameOverMesh.position.set(			posCamX,			posCamY+offsetY,	posCamZ+offsetZ	);
        this.startMesh.position.set(			posCamX,			posCamY+3,			posCamZ+offsetZ	);
		
		if(!this.camera){
			// regarder vers la caméra
			this.scoreMesh.lookAt(this.camera.position);
			this.instructionsMesh.lookAt(this.camera.position);
			this.gameOverMesh.lookAt(this.camera.position);
			this.startMesh.lookAt(this.camera.position);
	    }	

    }
}

// ---------------- Block ----------------
class Block {
    constructor(prevBlock){
        this.STATES={ACTIVE:"active",STOPPED:"stopped",MISSED:"missed"};
        this.MOVE_AMOUNT=12;
        this.dimension={width:0,height:0,depth:0};
        this.position={x:0,y:0,z:0};
        this.targetBlock=prevBlock;
        this.index=(this.targetBlock?this.targetBlock.index:0)+1;
        this.workingPlane=this.index%2?"x":"z";
        this.workingDimension=this.index%2?"width":"depth";

        this.dimension.width=this.targetBlock?this.targetBlock.dimension.width:10;
        this.dimension.height=this.targetBlock?this.targetBlock.dimension.height:2;
        this.dimension.depth=this.targetBlock?this.targetBlock.dimension.depth:10;
        this.position.x=this.targetBlock?this.targetBlock.position.x:0;
        this.position.y=this.dimension.height*this.index;
        this.position.z=this.targetBlock?this.targetBlock.position.z:-15;

        this.color=this.targetBlock?new THREE.Color(Math.random(),Math.random(),Math.random()):0x333344;
        this.state=this.index>1?this.STATES.ACTIVE:this.STATES.STOPPED;
        this.speed=-0.1-(this.index*0.005);
        if(this.speed<-4)this.speed=-4;
        this.direction=this.speed;

        const geometry=new THREE.BoxGeometry(this.dimension.width,this.dimension.height,this.dimension.depth);
        geometry.translate(this.dimension.width/2,this.dimension.height/2,this.dimension.depth/2);
        const material=new THREE.MeshToonMaterial({color:this.color});
        this.mesh=new THREE.Mesh(geometry,material);
        this.mesh.position.set(this.position.x,this.position.y,this.position.z);

        if(this.state===this.STATES.ACTIVE){
            this.position[this.workingPlane]=Math.random()>0.5?-this.MOVE_AMOUNT:this.MOVE_AMOUNT;
        }
    }

    reverseDirection(){ this.direction=this.direction>0?this.speed:Math.abs(this.speed); }

    place(){
        this.state=this.STATES.STOPPED;
        let overlap=this.targetBlock.dimension[this.workingDimension]-Math.abs(this.position[this.workingPlane]-this.targetBlock.position[this.workingPlane]);
        let blocksToReturn={plane:this.workingPlane,direction:this.direction};

        if(this.dimension[this.workingDimension]-overlap<0.3){
            overlap=this.dimension[this.workingDimension];
            blocksToReturn.bonus=true;
            this.position.x=this.targetBlock.position.x;
            this.position.z=this.targetBlock.position.z;
            this.dimension.width=this.targetBlock.dimension.width;
            this.dimension.depth=this.targetBlock.dimension.depth;
        }

        if(overlap>0){
            let choppedDimensions={...this.dimension};
            choppedDimensions[this.workingDimension]-=overlap;
            this.dimension[this.workingDimension]=overlap;

            let placedGeometry=new THREE.BoxGeometry(this.dimension.width,this.dimension.height,this.dimension.depth);
            placedGeometry.translate(this.dimension.width/2,this.dimension.height/2,this.dimension.depth/2);
            let placedMesh=new THREE.Mesh(placedGeometry,this.mesh.material);

            let choppedGeometry=new THREE.BoxGeometry(choppedDimensions.width,choppedDimensions.height,choppedDimensions.depth);
            choppedGeometry.translate(choppedDimensions.width/2,choppedDimensions.height/2,choppedDimensions.depth/2);
            let choppedMesh=new THREE.Mesh(choppedGeometry,this.mesh.material);

            let choppedPosition={...this.position};
            if(this.position[this.workingPlane]<this.targetBlock.position[this.workingPlane]) this.position[this.workingPlane]=this.targetBlock.position[this.workingPlane];
            else choppedPosition[this.workingPlane]+=overlap;

            placedMesh.position.set(this.position.x,this.position.y,this.position.z);
            choppedMesh.position.set(choppedPosition.x,choppedPosition.y,choppedPosition.z);

            blocksToReturn.placed=placedMesh;
            if(!blocksToReturn.bonus) blocksToReturn.chopped=choppedMesh;
        } else this.state=this.STATES.MISSED;

        return blocksToReturn;
    }

    tick(){
        if(this.state===this.STATES.ACTIVE){
            let value=this.position[this.workingPlane];
            if(value>this.MOVE_AMOUNT||value<-this.MOVE_AMOUNT)this.reverseDirection();
            this.position[this.workingPlane]+=this.direction;
            this.mesh.position[this.workingPlane]=this.position[this.workingPlane];
        }
    }
}

// ---------------- Game ----------------
class Game {
    constructor(){
        this.STATES={LOADING:"loading",PLAYING:"playing",READY:"ready",ENDED:"ended",RESETTING:"resetting"};
        this.blocks=[];
        this.state=this.STATES.LOADING;
        this.stage=new Stage();
        this.hud=new HUD(this.stage.scene);

        this.newBlocks=new THREE.Group();
        this.placedBlocks=new THREE.Group();
        this.choppedBlocks=new THREE.Group();
        this.stage.scene.add(this.newBlocks,this.placedBlocks,this.choppedBlocks);

        this.addBlock();
        this.state=this.STATES.READY;

        document.addEventListener("keydown", e=>{ if(e.code==="Space") this.onAction(); });
        document.addEventListener("click", ()=>this.onAction());

        const controller=this.stage.renderer.xr.getController(0);
        controller.addEventListener('selectstart',()=>this.onAction());
        this.stage.scene.add(controller);

        this.stage.renderer.setAnimationLoop(()=>this.tick());
    }

    onAction(){
        switch(this.state){
            case this.STATES.READY:this.startGame();break;
            case this.STATES.PLAYING:this.placeBlock();break;
            case this.STATES.ENDED:this.restartGame();break;
        }
    }

    startGame(){
        this.score=0;
        this.hud.setScore(this.score);
        this.hud.showInstructions(false);
        this.hud.showGameOver(false);
        this.hud.setStartText("");
        this.state=this.STATES.PLAYING;
        this.addBlock();
    }

    restartGame(){
        this.blocks=this.blocks.slice(0,1);
        this.placedBlocks.clear();
        this.choppedBlocks.clear();
        this.startGame();
    }

    placeBlock(){
        let currentBlock=this.blocks[this.blocks.length-1];
        let newBlocks=currentBlock.place();
        this.newBlocks.remove(currentBlock.mesh);
        if(newBlocks.placed) this.placedBlocks.add(newBlocks.placed);
        if(newBlocks.chopped){
            this.choppedBlocks.add(newBlocks.chopped);
            newBlocks.chopped.userData={velocity:-0.2};
        }
        this.addBlock();
    }

    addBlock(){
        let lastBlock=this.blocks[this.blocks.length-1];
        if(lastBlock && lastBlock.state===lastBlock.STATES.MISSED) return this.endGame();

        this.score=this.blocks.length-1;
        this.hud.setScore(this.score);

        let block=new Block(lastBlock);
        this.newBlocks.add(block.mesh);
        this.blocks.push(block);
		if(this.stage.renderer.xr.isPresenting) {
			// ajuster l'avatar en VR (à corriger)
		    //this.hud.position.set( this.hud.position.x, block.index, this.hud.position.z) ;
			this.stage.camera.position.set( this.stage.camera.position.x, block.index, this.stage.camera.position.z) ;
		}
		else{
			// ajuster la caméra verticale
			this.stage.camera.position.set( this.stage.camera.position.x, block.index, this.stage.camera.position.z) ;
			this.hud.updatePosition(false);
		}
    }

    endGame(){
        this.state=this.STATES.ENDED;
        this.hud.showGameOver(true);
        this.hud.setStartText("RESTART");
        this.hud.showInstructions(true);
    }

    tick(){
        if(this.blocks.length>0) this.blocks[this.blocks.length-1].tick();
        this.choppedBlocks.children.forEach(mesh=>{
            if(mesh.userData.velocity){
                mesh.position.y+=mesh.userData.velocity;
                mesh.userData.velocity-=0.01;
                if(mesh.position.y<-50) this.choppedBlocks.remove(mesh);
            }
        });
        this.stage.render();
    }
}

new Game();
</script>
</body>
</html>
